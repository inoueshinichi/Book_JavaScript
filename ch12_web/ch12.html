<!DOCTYPE html>
<html lang="ja">
<head>
  <!-- 文字セット -->
  <meta charset="UTF-8">

  <!-- レイアウト -->
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <!-- Webページの説明 -->
  <title>Web</title>
  <meta name="description" content="Webページの説明">
  <meta name="keywords" content="キーワード">

  <!-- OGP設定 -->
  <meta property="og:local" content="ja_JP" />
  <meta property="og:type" content="ウェブサイト名" />
  <meta property="og:title" content="" />
  <meta property="og:description" content="" />
  <meta property="og:url" content="" />
  <meta property="og:site_name" content="" />
  <meta property="og:image" content="" />

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet"
      integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">

  <style>
    h1 {
        background: black;
        color: white;
        margin: 10px;
        padding: 10px;
    }
    p {
        border: 1px solid gray;
        margin: 10px;
        padding: 5px;
    }
    strong {
        color: red;
        font-size: 1.5rem;
    }
  </style>

  <!-- <link href="style.css" rel="stylesheet"> -->

</head>
  <body>
    <!-- Main -->
    <main class="main">
        <div class="container" id="root_main">
            <section id="html" class="note">
            <h1>HTML</h1>
            <p><strong>HTML</strong>は文書のコンテンツと構造を表現します。</p>
            </section>
            <section id="css" class="note">
                <h1>CSS</h1>
                <p><strong>CSS</strong>はHTMLのスタイルを指定します。</p>
            </section>
            <section id="js" class="note">
                <h1>JavaScript</h1>
                <p><strong>JavaScript</strong>はHTMLとCSSの両方を制御できます。</p>
            </section>
        </div>
    </main>

    <script type="module" defer>
        'use strict'

        console.log("globalThis", globalThis)
        console.log("globalThis.document", globalThis.document)

        // console
        console.log("console.log")
        console.info("console.info")
        console.warn("console.warn")
        console.error("console.error")

        // location
        console.log("location.href", location.href)
        console.log("location.protocol", location.protocol)
        console.log("location.hostname", location.hostname)
        console.log("location.port", location.port)
        console.log("location.pathname", location.pathname)
        console.log("location.search", location.search)
        console.log("location.hash", location.hash)

        // navigator
        console.log("navigator.appName", navigator.appName)
        console.log("navigator.appVersion", navigator.appVersion)
        console.log("navigator.language", navigator.language)
        console.log("navigator.connection", navigator.connection)
        console.log("navigator.onLine", navigator.onLine)

        document.body.addEventListener("click", function() {
            this.style.filter = this.style.filter ? "" : "blur(5px)"
        })
    </script>

    <script type="module" defer>
        // DOMオブジェクト
        'use strict'

        console.log(Object.getPrototypeOf(document))
        console.log(document.childNodes[0])
        console.log(Object.getPrototypeOf(document.childNodes[0]))
        console.log(document.childNodes[1])
        console.log(Object.getPrototypeOf(document.childNodes[1]))
        console.log(document.childNodes[1].childNodes[0])
        console.log(Object.getPrototypeOf(document.childNodes[1].childNodes[0]))
        console.log(document.childNodes[1].childNodes[1]) // 改行テキスト
        console.log(Object.getPrototypeOf(document.childNodes[1].childNodes[1])) // 改行テキスト
        console.log(document.childNodes[1].childNodes[2]) // body
        console.log(Object.getPrototypeOf(document.childNodes[1].childNodes[2]))
        console.log(document.childNodes[1].childNodes[2].childNodes[1]) // <-- Main -->
        console.log(document.childNodes[1].childNodes[2].childNodes[3]) // <main>
        console.log(Object.getPrototypeOf(document.childNodes[1].childNodes[2].childNodes[3]))

        // bodyの背景色を変更
        const bodyElem = document.childNodes[1].childNodes[2]
        bodyElem.style.background = "gray"

        // いくつかのノードはdocumentを通じて直接アクセスできる
        document.body.style.color = 'blue'
    </script>

    <script type="module" defer>
        'use strict'
        // HTMLDocument
        // DocumentType
        // HTMLHtmlElement
        // HTMLHeadElement
        // HTMLBodyElemnetなど

        // Node: DOMツリーの各オブジェクトの継承元. 最も重要
        /*
        Node --- Document - HTMLDocument
              |- DocumentType
              |- Text
              |- Element
                    |- HTMLElement
                           |- HTMLHeadElement
                           |- HTMLBodyElement
                           |- HTMLInputElement
                            .....
        */

        /*
            Nodeオブジェクトのプロパティ
            getRootNode()
            parentNode
            parentElement
            childNodes
            firstChild
            lastChild
            previousSibling
            nextSibling

            Elementオブジェクトのプロパティ
            children
            firstElementChild
            lastElementChild
            previousElementSibling
            nextElementSibling
        */
        console.log("document.body.getRootNode()", document.body.getRootNode())
        console.log("document.body.childNodes", document.body.childNodes) // NodeList
        console.log("document.body.children", document.body.children) // HTMLCollection
        
        // HTMLCollectionはid属性に直接アクセスするプロパティを持つ
        console.log("document.getElementById('root_main').children.html", document.getElementById('root_main').children.html)
        console.log("document.getElementById('root_main').children.css", document.getElementById('root_main').children.css)

        // NodeListとHTMLCollectionは配列風オブジェクト.

        console.log("document.body.firstChild", document.body.firstChild)
        console.log("document.body.firstElementChild", document.body.firstElementChild)

        console.log("document.getElementById('root_main').children.css.previousSibling", 
            document.getElementById('root_main').children.css.previousSibling)
        console.log("document.getElementById('root_main').children.css.previousElementSibling", 
            document.getElementById('root_main').children.css.previusElementSibling)
    </script>

    <script type="module" defer>
        'use strict'

        /* 要素を探索する手段
            getElementsByTagName()
            getElementById()
            getElementsByClassName()
            querySelector()
            querySelectorAll()
        */
       console.log('--- 要素を探索する手段 ---')
       console.log(document.getElementsByTagName("strong"))
       console.log(document.getElementById('root_main').children.css.getElementsByTagName('strong'))
       console.log(document.getElementById('js'))
       console.log(document.getElementsByClassName('note'))

       console.log(document.querySelector("meta[charset=UTF-8]"))
       console.log(document.querySelectorAll(".note h1"))
       console.log(document.querySelectorAll(".note p"))

       /*
        要素の情報を調べる
        nodeType: Document, Node, Text, HTML***Elementなど型チェック
        ELEMENT_NODE: 1
        TEXT_NODE: 3
        COMMENT_NODE: 8
        DOCUMENT_NODE: 9
        DOCUMENT_TYPE_NODE: 10
        */ 
       console.log("--- 要素の情報を調べる ---")
       console.log(document.nodeType)
       console.log("document.nodeType === Node.DOCUMENT_NODE", document.nodeType === Node.DOCUMENT_NODE)
       console.log(document.body.nodeType)
       console.log("document.body.nodeType === Node.ELEMENT_NODE", document.body.nodeType === Node.ELEMENT_NODE)

       // HTMLタグの場合のタグ名の確認(Node系とElement系の2種類の確認方法がある)
       console.log("document.nodeName", document.nodeName) // Node系 for Node.   -> #{object}
       console.log("document.tagName", document.tagName)   // Element系 for Node -> undefined
       console.log("document.body.nodeName", document.body.nodeName)
       console.log("document.body.tagName", document.body.tagName)

        /**要素の属性を操作する
         * idとclass(className)はElementオブジェクトが特別扱いでJavaScriptのオブジェクトからプロパティとして直接指定できる。
         * 上記以外は, attributesとgetAttributeNames()を使う
         */
        const js = document.getElementById("js")
        console.log("js.id", js.id) // js
        js.id = "javascript" // 属性の変更
        console.log("js", js)
        console.log("document.getElementById('js')", document.getElementById('js'))
        console.log("document.getElementById('javascript')", document.getElementById('javascript'))

        console.log("document.getElementById('root_main').children.css.className", 
            document.getElementById('root_main').children.css.className)

        // classNameに新規class名を追加
        const css = document.getElementById('root_main').children.css
        css.className += " stylesheet"
        console.log('css', css)
        console.log(css.className.split(" "))
        console.log(css.className.split(' ').includes('stylesheet'))

        // 複数class名を配列風オブジェクトとして取得できるclassList
        console.log("css.classList", css.classList) // DOMTokenList
        css.classList.add("css")
        console.log(css.classList)

        console.log("--- idとclass(className)以外の属性へのアクセス&操作 ---")
        console.log("document.head.firstElementChild", document.head.firstElementChild)
        console.log("document.head.firstElementChild.attributes", document.head.firstElementChild.attributes) // NamedNodeMap

        // Attrオブジェクト
        console.log("document.head.firstElementChild.attributes[0]", document.head.firstElementChild.attributes[0])
        const charset = document.head.firstElementChild.attributes[0]
        console.log("charset", charset)
        console.log("charset.name", charset.name) // Attr.name
        console.log("charset.value", charset.value) // Attr.value
        console.log("document.head.firstElementChild.getAttributeNames()", document.head.firstElementChild.getAttributeNames())

        // hasAttribute()
        // getAttribute()
        // setAttribute()
        // removeAttribute()
        const meta = document.head.firstElementChild
        console.log("meta", meta)
        console.log("meta.hasAttribute('charset')", meta.hasAttribute('charset'))
        console.log("meta.getAttribute('charset')", meta.getAttribute('charset'))
        console.log("meta.setAttribute('charset', 'utf8')", meta.setAttribute('charset', 'utf8'))
        console.log(meta)
        // console.log("meta.removeAttribute('charset')", meta.removeAttribute('charset'))
        // console.log(meta)
    </script>

    <script type="module" defer>
        'use strict'

        /**要素のコンテンツを操作する
         * textContent : 全てのテキストを返す
         * innerText   : 実際に表示されているテキストだけ表示(タグ名含めて) 
         * removeChild({node}) : 子ノードの削除
         * createElement("{tag}") : HTMLElementの作成
         * createTextNode("{text}") : テキストNodeの作成
         * appendChild() : 子ノードリストの最後にノードを一つ追加
         * insertBefore() : 基準ノードと新ノードを引数に取り、子ノードリストの基準ノードの前にノードを一つ追加
         * prepend() : 子ノードリストの最初に任意個数のノードを追加
         * apppend() : 子ノードリストの最後に任意個数のノードを追加
         * replaceChild() : 要素を入れ替える
         */
        document.querySelector("strong").style.display = "none"
        const htmlNote = document.querySelector("p")
        console.log("htmlNote.textContent", htmlNote.textContent)
        console.log("htmlNote.innerText", htmlNote.innerHTML)

        // 要素の書き換え
        htmlNote.textContent = "HTMLは文書のコンテンツと構造を表現します。"
        console.log("htmlNote", htmlNote)

        // 要素を削除
        const node = document.getElementById('root_main').firstElementChild
        console.log("node", node)
        console.log("node.parentNode.removeChild(node)", node.parentNode.removeChild(node))

        // 要素/ノードの作成
        const divElem = document.createElement('div')
        const textNode = document.createTextNode('HTML')
        console.log('divElem', divElem)
        console.log('textNode', textNode)

        // 要素を追加
        let root = document.getElementById('root_main')
        root.insertBefore(document.createTextNode('insertBefore(js)'), root.children.js)
        root.appendChild(document.createElement('br'))
        root.appendChild(document.createTextNode("appendChild"))
        root.append(document.createElement('hr'), "append")
        root.prepend("prepend", document.createElement('hr'))

        let fragment = new DocumentFragment() // reflowによる描画パフォーマンスを防ぐために複数要素を一括で描画する
        fragment.appendChild(document.createTextNode('Tiny Tank'))
        fragment.appendChild(document.createElement('hr'))
        fragment.appendChild(document.createTextNode('SSB88'))
        root.appendChild(fragment)


        // 要素を入れ替える(インタラクション)
        let fragmentForCSS = new DocumentFragment()
        fragmentForCSS.appendChild(document.createElement('hr'))
        fragmentForCSS.appendChild(document.createTextNode("CSSセクションは入れ替えられました."))
        fragmentForCSS.appendChild(document.createElement('hr'))
        root.replaceChild(fragmentForCSS, root.children.css)

        // contentEditable属性 (ユーザーがGUIを使って既存要素を制御する)
        // document.body.contentEditable = true

        // designMode属性 for documentオブジェクト
        // HTML文書全体が編集可能になる
        // document.execCommand()メソッドを使って自由にHTML文章を操作できる
        // document.designMode = true
    </script>

    <script type="module" defer>
        'use strict'

        /* CSSオブジェクトモデル(CSSOM)
        DOMのCSS版: つまりCSSの内部表現
        CSSOMで<style>タグで指定したCSSそのもにアクセス可能
        <style>
            h1 {
                background: black;
                color: white;
                margin: 10px;
                padding: 10px;
            }
            p {
                border: 1px solid gray;
                margin: 10px;
                padding: 5px;
            }
            strong {
                color: red;
                font-size: 1.5rem;
            }
        </style>
        */

        /* document.styleSheet 
            CSSStyleSheet: 一つの<style>タグが保持いているCSSを指す. cssRulesプロパティとして複数のCSSRuleオブジェクトを保持する.
            CSSRule: CSSのルール. styleルール + importルール, mediaルール.
            CSSStyleRule: CSSのスタイルルールを表す.
            CSSMediaRule: 
            CSSImportRule:
            CSSKeyframesRule: 
            CSSStyleDeclaration: CSS宣言を表す.
        */
        console.log("document.styleSheets[0].cssRules", document.styleSheets[0].cssRules) // CSSRuleList

        console.log("document.styleSheets[0].cssRules[0]", document.styleSheets[0].cssRules[0])

        console.log("document.styleSheets[0].cssRules[0].selectorText", document.styleSheets[0].cssRules[0].selectorText)

        console.log("document.styleSheets[0].cssRules[0].style", document.styleSheets[0].cssRules[0].style)

        // CSSStyleDeclarationオブジェクトはインデックスでCSSプロパティに名にアクセスできるだけでなく
        // CSSプロパティ名でその値にもアクセスできる.
        for (let rule of document.styleSheets[1].cssRules) {
            const selector = rule.selectorText
            for (let prop of rule.style) {
                console.log(`${selector}: { ${prop}: ${rule.style[prop]} }`)
            }
        }

        /* CSSルールを書き換える */

        // setPropertyとremovePropertyでCSSStyleDeclarationを編集できる
        let h1Style = document.styleSheets[1].cssRules[0].style
        console.log('h1Style', h1Style)
        h1Style.fontSize = '50%'
        console.log('h1Style["font-size"]', h1Style["font-size"])
        h1Style.setProperty("font-size", "300%", "important")
        console.log('h1Style["font-size"]', h1Style["font-size"])
        h1Style.removeProperty("font-size")
        console.log('h1Style["font-size"]', h1Style["font-size"])

        // CSSStyleRuleオブジェクトを適用するセレクタを変更できる
        document.styleSheets[1].cssRules[0].selectorText = '.note'


        /* 新しいCSSルールを追加する */
        document.styleSheets[1].insertRule(`
            .note {
              margin: 4px;
              border: 1px solid black;
              background-color: lightYellow;
            }
        `/*, 2*/)

        /* インデックス指定でCSSルールを削除 */
        // document.styleSheets[0].deleteRule(0)
    </script>

    <script type="module" defer>
        'use strict'

        document.body.addEventListener('click', e => {
            e.target.style.backgroundColor = `#${Math.floor(Math.random() * 0xffffff).toString(16)}`
        })

        document.body.addEventListener("click", () => console.log('最初のイベントハンドラ'))
        const secondHandler = () => console.log("二つ目のイベントハンドラ")
        document.body.addEventListener("click", secondHandler)
        document.body.dispatchEvent(new Event("click"))
        document.body.removeEventListener("click", secondHandler)

        /* キーボードイベント
            KeybordEvent
            1) key
            2) code
            3) altKey
            4) ctrlKey
            5) metaKey
            6) shiftKey
         */
        let keyLogger = e => console.log(`
        type: ${e.type} 
        code: ${e.code} 
        key: ${e.key} 
        shift: ${e.shiftKey}
        `)
        document.addEventListener("keydown", keyLogger)
        document.addEventListener("keyup", keyLogger)

        /* マウスイベント 
            MouseEvent
            1) clientX
            2) clientY
            3) altKey
            4) ctrlKey
            5) metaKey
            6) shiftKey
        */
       let clicking = false
       document.addEventListener("mousedown", () => clicking = true)
       document.addEventListener("mouseup", () => clicking = false)
       document.addEventListener("mousemove", e => {
        if (!clicking) return
        console.log(`
            clientX: ${e.clientX}
            clientY: ${e.clientY}
            shiftKey: ${e.shiftKey}
        `)
       })

       /* 自作イベント */
       let callEvent = new CustomEvent("call", {detail: "もしもし私メリーさん"})
       document.addEventListener("call", e => console.log(e.detail))
       document.dispatchEvent(callEvent)

       /* イベントハンドラの探索順序
        前提: ある要素でイベントが発火すると、その祖先要素に登録したイベントハンドラも合わせて実行される.
        キャプチャフェーズ -> イベント発火DOM発見 -> バブリングフェーズ
       */
      window.addEventListener("click", e => console.log(`Ph.${e.eventPhase} bubble window`))
      window.addEventListener("click", e => console.log(`Ph.${e.eventPhase} capture window`), true)
      document.addEventListener("click", e => console.log(`Ph.${e.eventPhase} bubble document`))
      document.addEventListener("click", e => console.log(`Ph.${e.eventPhase} capture document`), true)
      document.body.addEventListener("click", e => console.log(`Ph.${e.eventPhase} bubble body`))
      document.body.addEventListener("click", e => console.log(`Ph.${e.eventPhase} capture body`), true)

      /* イベントの伝播を止める
       止めたい要素のaddEventListner(capture or bubble)でe.stopPropagation()を実行
       */
      window.addEventListener("click", e => e.stopPropagation(), true) // 同一フェーズでは追加した順にイベントハンドラが実行される.

    </script>


    <script type="module" defer>
        'use strict'

        /* Web Components
            カスタマイズDOMの作成仕様
            1) Costom Elements: カスタム要素を作成するためのAPI
            2) Shadow DOM: スクリプトやスタイルの適用範囲を決めるShadow DOMの管理用API
            3) HTML Template: 画面に描画されない<template>要素と<slot>要素.
        */
        
        class InfoPanel extends HTMLElement {
            constructor() {
                super()
            }
        }

        

    </script>

  </body>
</html>